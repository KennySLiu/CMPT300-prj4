diff -rupN linux_patch/linux_v4.13.9/arch/x86/entry/syscalls/syscall_64.tbl linux_v4.13.9/arch/x86/entry/syscalls/syscall_64.tbl
--- linux_patch/linux_v4.13.9/arch/x86/entry/syscalls/syscall_64.tbl	2018-03-07 02:41:20.000000000 -0800
+++ linux_v4.13.9/arch/x86/entry/syscalls/syscall_64.tbl	2018-03-23 18:42:35.629095307 -0700
@@ -339,6 +339,9 @@
 330	common	pkey_alloc		sys_pkey_alloc
 331	common	pkey_free		sys_pkey_free
 332	common	statx			sys_statx
+340	common	cs300_test		sys_cs300_test
+341	common	array_stats		sys_array_stats
+342	common	process_ancestors	sys_process_ancestors
 
 #
 # x32-specific system call numbers start at 512 to avoid cache impact
diff -rupN linux_patch/linux_v4.13.9/cs300/array_stats.c linux_v4.13.9/cs300/array_stats.c
--- linux_patch/linux_v4.13.9/cs300/array_stats.c	1969-12-31 16:00:00.000000000 -0800
+++ linux_v4.13.9/cs300/array_stats.c	2018-03-25 19:49:51.310601275 -0700
@@ -0,0 +1,53 @@
+#include "array_stats.h"
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+
+/* Implementing an array_stats function: */
+asmlinkage long sys_array_stats( struct array_stats *stats,
+                 long data[],
+                 long size){
+    long currMin = 0;
+    long currMax = 0;    
+    long currSum = 0;
+    int i = 0;
+    long dataval = 0;
+    struct array_stats currStats;
+
+    printk("DEBUG: sys_array_stats called with data = %p, size = %ld, stats = %p",
+                 (void *) data, size, (void *) stats);
+    
+    if (size <= 0){
+        printk("DEBUG: in sys_array_stats: size was <= 0!");
+        return -EINVAL;
+    }
+
+    for (i = 0; i < size; ++i){
+
+        if ( copy_from_user(&dataval, &data[i], (unsigned long) sizeof(long)) ){
+            printk("DEBUG: in sys_array_stats: copy from data at index %d failed!", i);
+            return -EFAULT;
+        }
+
+        if (i == 0){
+            currMin = data[i];
+            currMax = data[i];
+            currSum = data[i];
+        } else {
+            currMin = data[i] < currMin ? data[i] : currMin;
+            currMax = data[i] > currMax ? data[i] : currMax;
+            currSum += data[i];
+        }
+    }
+
+    currStats.min = currMin;
+    currStats.max = currMax;
+    currStats.sum = currSum;
+
+    if (copy_to_user(stats, &currStats, (unsigned long) sizeof(struct array_stats))){
+        printk("DEBUG: in sys_array_stats: copy to stats array failed!");
+        return -EFAULT;
+    }
+      
+    return 0;  
+
+}
diff -rupN linux_patch/linux_v4.13.9/cs300/array_stats.h linux_v4.13.9/cs300/array_stats.h
--- linux_patch/linux_v4.13.9/cs300/array_stats.h	1969-12-31 16:00:00.000000000 -0800
+++ linux_v4.13.9/cs300/array_stats.h	2018-03-23 01:07:45.419103845 -0700
@@ -0,0 +1,11 @@
+// Define the array_stats struct for the array_stats sys-call.
+#ifndef _ARRAY_STATS_H_
+#define _ARRAY_STATS_H_
+
+struct array_stats{
+    long min;
+    long max;
+    long sum;
+};
+
+#endif
diff -rupN linux_patch/linux_v4.13.9/cs300/cs300_test.c linux_v4.13.9/cs300/cs300_test.c
--- linux_patch/linux_v4.13.9/cs300/cs300_test.c	1969-12-31 16:00:00.000000000 -0800
+++ linux_v4.13.9/cs300/cs300_test.c	2018-03-23 00:08:32.655117202 -0700
@@ -0,0 +1,15 @@
+#include <linux/kernel.h>
+
+// Implement a HelloWorld system call
+// Argument is passed from call in user space.
+asmlinkage long sys_cs300_test(int argument)
+{
+	long result = 0;
+
+	printk("Hello World!\n");
+	printk("--syscall argument %d\n", argument);
+
+	result = argument + 1;
+	printk("--returning %d + 1 = %ld\n", argument, result);
+	return result;
+}
diff -rupN linux_patch/linux_v4.13.9/cs300/Makefile linux_v4.13.9/cs300/Makefile
--- linux_patch/linux_v4.13.9/cs300/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux_v4.13.9/cs300/Makefile	2018-03-23 19:03:46.458577408 -0700
@@ -0,0 +1 @@
+obj-y := cs300_test.o array_stats.o process_ancestors.o
diff -rupN linux_patch/linux_v4.13.9/cs300/process_ancestors.c linux_v4.13.9/cs300/process_ancestors.c
--- linux_patch/linux_v4.13.9/cs300/process_ancestors.c	1969-12-31 16:00:00.000000000 -0800
+++ linux_v4.13.9/cs300/process_ancestors.c	2018-03-25 18:04:14.220954704 -0700
@@ -0,0 +1,88 @@
+#include "process_ancestors.h"
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/cred.h>
+
+/* Implementing process_ancestors function: */
+asmlinkage long sys_process_ancestors(struct process_info info_array[], 
+                long size, 
+                long *num_filled){
+    
+    struct task_struct *currTask = current;
+    struct list_head    *currChildren;
+    struct list_head    *currSiblings;
+    struct list_head    *indexer;
+    struct process_info	currPInfo;
+    long index;
+    long currFilled;
+    
+    printk("DEBUG: sys_process_ancestors called! infoarray = %p, Size = %ld, num_filled = %p\n", info_array, size, num_filled);
+
+    if (size <= 0){
+        printk("\nDEBUG: in sys_process_ancestors: size was <= 0!\n");
+        return -EINVAL;
+    }
+
+    index = 0;
+
+    while (index < size ){
+        if (currTask->parent == currTask){
+            break;
+        }
+
+        currPInfo.pid = (long) currTask->pid;
+       	strcpy( currPInfo.name, currTask->comm );
+        currPInfo.state = currTask->state;
+        currPInfo.uid = (long) (currTask->cred)->uid.val;
+        currPInfo.nvcsw = (long) currTask->nvcsw;
+        currPInfo.nivcsw = (long) currTask->nivcsw;
+        currPInfo.num_children = 0; /* Counting children is done immediately after this */
+        currPInfo.num_siblings = 0; /* Counting siblings is done after counting children */
+        
+        currChildren = &(currTask->children);
+        currSiblings = &(currTask->sibling);
+
+        /* Getting the number of children: */
+        list_for_each(indexer, currChildren){
+            ++currPInfo.num_children;
+        }
+        /* Getting the number of siblings: */
+        list_for_each(indexer, currSiblings){
+            ++currPInfo.num_siblings;
+        }
+        --currPInfo.num_siblings; /* Delete itself, because otherwise it gets counted as it's own sibling */
+
+
+        printk("\nDEBUG: At index %ld, size = %ld, pid = %ld, name = %s, state = %ld, uid = %ld, nvcsw = %ld,\n\
+                        nivcsw = %ld, num_children = %ld, num_siblings = %ld.\n", index, size, currPInfo.pid,
+                        currPInfo.name, currPInfo.state, currPInfo.uid, currPInfo.nvcsw, 
+                        currPInfo.nivcsw, currPInfo.num_children, currPInfo.num_siblings);
+
+
+        printk("\nDEBUG: &currFilled = %p", &currFilled);
+        printk("\nDEBUG: num_flled = %p", num_filled);
+
+        if (copy_to_user(num_filled, &currFilled, (unsigned long) sizeof(long int))){
+            printk("DEBUG: in sys_process_ancestors: copying to num_filled failed!");
+            return -EFAULT;
+        }
+        if ( copy_to_user(&info_array[index], &currPInfo, (unsigned long) sizeof(struct process_info)) ){
+            printk("DEBUG: in sys_process_ancestors: Copying to array failed!");
+            return -EFAULT;
+        }
+        
+/*        printk("DEBUG: Just finished writing to index %ld\n", index);*/
+
+        /* Write to the next index on the next loop: */
+        index += 1;
+        currFilled = index + 1;
+        currTask = currTask->parent;
+
+        
+    }
+
+    return 0;
+}
diff -rupN linux_patch/linux_v4.13.9/cs300/process_ancestors.h linux_v4.13.9/cs300/process_ancestors.h
--- linux_patch/linux_v4.13.9/cs300/process_ancestors.h	1969-12-31 16:00:00.000000000 -0800
+++ linux_v4.13.9/cs300/process_ancestors.h	2018-03-23 18:38:32.007722397 -0700
@@ -0,0 +1,17 @@
+// Structure to hold values returned by process_ancestors sys-call
+#ifndef _PROCESS_ANCESTORS_H
+#define _PROCESS_ANCESTORS_H
+
+#define ANCESTOR_NAME_LEN 16
+struct process_info {
+    long pid;                     /* Process ID */
+    char name[ANCESTOR_NAME_LEN]; /* Program name of process */
+    long state;                   /* Current process state */
+    long uid;                     /* User ID of process owner */
+    long nvcsw;                   /* # voluntary context switches */
+    long nivcsw;                  /* # involuntary context switches */
+    long num_children;            /* # children process has */
+    long num_siblings;            /* # sibling process has */
+};
+
+#endif
diff -rupN linux_patch/linux_v4.13.9/Makefile linux_v4.13.9/Makefile
--- linux_patch/linux_v4.13.9/Makefile	2018-03-07 02:41:46.000000000 -0800
+++ linux_v4.13.9/Makefile	2018-03-23 00:04:55.326186752 -0700
@@ -941,7 +941,7 @@ endif
 
 
 ifeq ($(KBUILD_EXTMOD),)
-core-y		+= kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/
+core-y		+= kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/ cs300/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
